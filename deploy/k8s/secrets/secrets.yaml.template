# SPDX-License-Identifier: PLMP-1.0-or-later
# cicd-hyper-a Kubernetes Secrets Template
#
# This is a TEMPLATE file with placeholders. Do NOT commit actual secrets!
#
# Usage:
#   1. Copy this file: cp secrets.yaml.template secrets.yaml
#   2. Replace all ${PLACEHOLDER} values with base64-encoded secrets
#   3. Apply: kubectl apply -f secrets.yaml
#   4. NEVER commit secrets.yaml to version control
#
# To base64 encode values:
#   echo -n 'your-secret-value' | base64
#
# For production, use one of:
#   - sealed-secrets.yaml.template (Bitnami Sealed Secrets)
#   - external-secrets.yaml.template (External Secrets Operator)
#   - sops-secrets.yaml.template (Mozilla SOPS)
#
---
apiVersion: v1
kind: Namespace
metadata:
  name: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/managed-by: kubectl
---
# =============================================================================
# Core Application Secrets
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: cicd-hyper-a-core-secrets
  namespace: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/component: core-secrets
    app.kubernetes.io/part-of: cicd-hyper-a
  annotations:
    description: "Core application secrets for cicd-hyper-a"
type: Opaque
data:
  # ArangoDB Credentials
  # Generate strong passwords: openssl rand -base64 32
  # Then base64 encode: echo -n 'generated-password' | base64
  arangodb-root-user: ${ARANGODB_ROOT_USER_B64}
  arangodb-root-password: ${ARANGODB_ROOT_PASSWORD_B64}
  arangodb-app-user: ${ARANGODB_APP_USER_B64}
  arangodb-app-password: ${ARANGODB_APP_PASSWORD_B64}

  # ArangoDB Connection String
  # Format: arangodb://user:password@host:port/database
  arangodb-connection-string: ${ARANGODB_CONNECTION_STRING_B64}

  # Dragonfly (Redis-compatible) Password
  dragonfly-password: ${DRAGONFLY_PASSWORD_B64}
  dragonfly-connection-string: ${DRAGONFLY_CONNECTION_STRING_B64}

  # Application JWT Secret (for API authentication)
  # Generate: openssl rand -base64 64
  jwt-secret: ${JWT_SECRET_B64}

  # API encryption key (for encrypting sensitive data at rest)
  # Generate: openssl rand -base64 32
  encryption-key: ${ENCRYPTION_KEY_B64}

---
# =============================================================================
# Git Forge Credentials
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: forge-credentials
  namespace: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/component: forge-credentials
    app.kubernetes.io/part-of: cicd-hyper-a
  annotations:
    description: "Git forge (GitHub, GitLab, Bitbucket) API tokens"
type: Opaque
data:
  # GitHub Personal Access Token (Classic or Fine-grained)
  # Required scopes: repo, read:org, workflow
  # Create at: https://github.com/settings/tokens
  github-token: ${GITHUB_TOKEN_B64}
  github-username: ${GITHUB_USERNAME_B64}

  # GitHub App credentials (alternative to PAT)
  # Preferred for organization-wide access
  github-app-id: ${GITHUB_APP_ID_B64}
  github-app-private-key: ${GITHUB_APP_PRIVATE_KEY_B64}
  github-app-installation-id: ${GITHUB_APP_INSTALLATION_ID_B64}

  # GitLab Personal Access Token
  # Required scopes: api, read_repository, write_repository
  # Create at: https://gitlab.com/-/profile/personal_access_tokens
  gitlab-token: ${GITLAB_TOKEN_B64}
  gitlab-username: ${GITLAB_USERNAME_B64}

  # Bitbucket App Password
  # Required permissions: Repositories (Read, Write), Pull requests (Read, Write)
  # Create at: https://bitbucket.org/account/settings/app-passwords/
  bitbucket-username: ${BITBUCKET_USERNAME_B64}
  bitbucket-app-password: ${BITBUCKET_APP_PASSWORD_B64}

  # Codeberg Token
  # Create at: https://codeberg.org/user/settings/applications
  codeberg-token: ${CODEBERG_TOKEN_B64}
  codeberg-username: ${CODEBERG_USERNAME_B64}

  # Gitea Token (self-hosted)
  gitea-token: ${GITEA_TOKEN_B64}
  gitea-username: ${GITEA_USERNAME_B64}
  gitea-url: ${GITEA_URL_B64}

---
# =============================================================================
# External API Keys
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: external-api-keys
  namespace: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/component: api-keys
    app.kubernetes.io/part-of: cicd-hyper-a
  annotations:
    description: "External service API keys"
type: Opaque
data:
  # Webhook signing secret (for validating incoming webhooks)
  # Generate: openssl rand -hex 32
  webhook-secret: ${WEBHOOK_SECRET_B64}

  # Slack webhook URL (for notifications)
  slack-webhook-url: ${SLACK_WEBHOOK_URL_B64}

  # Discord webhook URL (for notifications)
  discord-webhook-url: ${DISCORD_WEBHOOK_URL_B64}

  # Datadog API key (for metrics/monitoring)
  datadog-api-key: ${DATADOG_API_KEY_B64}
  datadog-app-key: ${DATADOG_APP_KEY_B64}

  # Sentry DSN (for error tracking)
  sentry-dsn: ${SENTRY_DSN_B64}

---
# =============================================================================
# Monitoring Credentials
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: monitoring-secrets
  namespace: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/component: monitoring
    app.kubernetes.io/part-of: cicd-hyper-a
  annotations:
    description: "Monitoring stack credentials"
type: Opaque
data:
  # Grafana admin credentials
  grafana-admin-user: ${GRAFANA_ADMIN_USER_B64}
  grafana-admin-password: ${GRAFANA_ADMIN_PASSWORD_B64}

  # Prometheus remote write credentials (if using hosted Prometheus)
  prometheus-remote-write-user: ${PROMETHEUS_REMOTE_WRITE_USER_B64}
  prometheus-remote-write-password: ${PROMETHEUS_REMOTE_WRITE_PASSWORD_B64}

---
# =============================================================================
# TLS Certificates (Reference to cert-manager)
# =============================================================================
# For production TLS, use cert-manager with Let's Encrypt or your CA
# This creates a Certificate resource that cert-manager will fulfill
#
# Prerequisites:
#   1. Install cert-manager: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.0/cert-manager.yaml
#   2. Create ClusterIssuer (see below)
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: cicd-hyper-a-tls
  namespace: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/component: tls
    app.kubernetes.io/part-of: cicd-hyper-a
spec:
  secretName: cicd-hyper-a-tls-secret
  duration: 2160h  # 90 days
  renewBefore: 360h  # 15 days before expiry
  isCA: false
  privateKey:
    algorithm: RSA
    encoding: PKCS1
    size: 4096
  usages:
    - server auth
    - client auth
  dnsNames:
    - cicd.hyperpolymath.dev
    - api.cicd.hyperpolymath.dev
    - registry.cicd.hyperpolymath.dev
    - "*.cicd.hyperpolymath.dev"
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
    group: cert-manager.io
---
# ClusterIssuer for Let's Encrypt (apply once per cluster)
# Uncomment and apply separately if not already configured
#
# apiVersion: cert-manager.io/v1
# kind: ClusterIssuer
# metadata:
#   name: letsencrypt-prod
# spec:
#   acme:
#     server: https://acme-v02.api.letsencrypt.org/directory
#     email: ${LETSENCRYPT_EMAIL}
#     privateKeySecretRef:
#       name: letsencrypt-prod-account-key
#     solvers:
#       - http01:
#           ingress:
#             class: nginx
---
# Manual TLS secret (only if NOT using cert-manager)
# Uncomment if you need to provide certificates manually
#
# apiVersion: v1
# kind: Secret
# metadata:
#   name: cicd-hyper-a-tls-manual
#   namespace: cicd-hyper-a
#   labels:
#     app.kubernetes.io/name: cicd-hyper-a
#     app.kubernetes.io/component: tls
#     app.kubernetes.io/part-of: cicd-hyper-a
# type: kubernetes.io/tls
# data:
#   # Base64 encoded PEM certificate
#   tls.crt: ${TLS_CERTIFICATE_B64}
#   # Base64 encoded PEM private key
#   tls.key: ${TLS_PRIVATE_KEY_B64}
#   # Optional: CA certificate chain
#   ca.crt: ${TLS_CA_CERTIFICATE_B64}

---
# =============================================================================
# Docker Registry Credentials
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: registry-credentials
  namespace: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/component: registry
    app.kubernetes.io/part-of: cicd-hyper-a
  annotations:
    description: "Container registry pull/push credentials"
type: kubernetes.io/dockerconfigjson
data:
  # Docker config JSON (base64 encoded)
  # Generate: kubectl create secret docker-registry ... --dry-run=client -o jsonpath='{.data.\.dockerconfigjson}'
  # Or manually base64 encode a .dockerconfigjson file
  .dockerconfigjson: ${DOCKER_CONFIG_JSON_B64}

---
# =============================================================================
# Service Account Tokens (for RBAC-enabled clusters)
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: cicd-hyper-a-sa-token
  namespace: cicd-hyper-a
  labels:
    app.kubernetes.io/name: cicd-hyper-a
    app.kubernetes.io/component: service-account
    app.kubernetes.io/part-of: cicd-hyper-a
  annotations:
    kubernetes.io/service-account.name: cicd-hyper-a
type: kubernetes.io/service-account-token
